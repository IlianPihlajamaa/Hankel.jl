<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documentation · Hankel.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Hankel.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Documentation</a><ul class="internal"><li><a class="tocitem" href="#Normalisation-1"><span>Normalisation</span></a></li><li><a class="tocitem" href="#On-axis-and-symmetric-samples-1"><span>On-axis and symmetric samples</span></a></li><li><a class="tocitem" href="#Function-Reference-1"><span>Function Reference</span></a></li></ul></li><li><a class="tocitem" href="derivations/">Derivations</a></li><li><a class="tocitem" href="autodiff/">Automatic Differentiation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/chrisbrahms/Hankel.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Hankel-1"><a class="docs-heading-anchor" href="#Hankel-1">Hankel</a><a class="docs-heading-anchor-permalink" href="#Hankel-1" title="Permalink"></a></h1><p><code>Hankel</code> implements the quasi-discrete Hankel transform (QDHT) as introduced in <a href="https://doi.org/10.1016/0010-4655(87)90204-9">H. F. Johnson, Comput. Phys. Commun., 43, 2 (1987)</a>, laid out for 0-order in <a href="https://www.osapublishing.org/ol/abstract.cfm?uri=ol-23-6-409">L. Yu, <em>et al.</em>, Optics Letters 23 (1998)</a>, and extended to higher orders in <a href="https://www.osapublishing.org/abstract.cfm?URI=josaa-21-1-53">M. Guizar-Sicairos and J. C. Gutiérrez-Vega, JOSA A 21, 53 (2004)</a>. We generalized the cylindrical QDHT in the above publications to its (hyper)spherical form. The forward <span>$p^{\mathrm{th}}$</span>-order (hyper)spherical Hankel transform of the radially symmetric function <span>$f(r)$</span> is defined as</p><div>\[\tilde{f}(k) = c_n^{-1} \int_0^\infty f(r) j_p^n(kr) r^n\,\mathrm{d}r\,,\]</div><p>where <span>$c_n$</span> is a constant (see <a href="#Hankel.sphbesselj_scale-Tuple{Any}"><code>sphbesselj_scale</code></a>), and <span>$j_p^n(x)$</span> is the <span>$p^{\mathrm{th}}$</span>-order (hyper)spherical Bessel function of the first kind with spherical dimension <span>$n$</span> (see <a href="#Hankel.sphbesselj-Tuple{Any,Any,Any}"><code>sphbesselj</code></a>). Correspondingly, the inverse transform is</p><div>\[f(r) = c_n^{-1} \int_0^\infty \tilde{f}(k) j_p^n(kr) k^n\,\mathrm{d}k\,.\]</div><p>Note that here, <span>$k$</span> includes the factor of <span>$2\pi$</span>, i.e. it is spatial angular frequency.</p><p>The remainder of the documentation considers without loss of generalization only the cylindrical case (<span>$n=1$</span>, with <span>$j_p^n(x) = J_p(x)$</span>).</p><p>The QDHT approximates these transforms under the assumption that <span>$f(r) = 0$</span> for <span>$r &gt; R$</span> where <span>$R$</span> is the aperture size. By expanding <span>$f(r)$</span> as a Fourier-Bessel series and choosing to sample <span>$f(r)$</span> at coordinates <span>$r_n = j_nR/j_{N+1}$</span>, where <span>$j_n$</span> is the <span>$n^{\mathrm{th}}$</span> zero of <span>$J_p(x)$</span> and <span>$N$</span> is the number of samples, the Hankel transform turns into a matrix-vector multiplication.</p><p><code>Hankel</code> follows the <a href="https://juliamath.github.io/AbstractFFTs.jl/stable/"><code>AbstractFFTs</code></a> approach of planning a transform in advance by creating a <a href="#Hankel.QDHT"><code>QDHT</code></a> object, which can then be used to transform an array using multiplication (<a href="#Base.:*-Tuple{QDHT,Any}"><code>*</code></a> or <a href="#LinearAlgebra.mul!-Tuple{Any,QDHT,Any}"><code>mul!</code></a>) and to transform back by left-division (<a href="#Base.:\\-Tuple{QDHT,Any}"><code>\</code></a> or <a href="#LinearAlgebra.ldiv!-Tuple{Any,QDHT,Any}"><code>ldiv!</code></a>). In contrast to <code>AbstractFFTs</code>, however, <strong>pre-planning a transform is required</strong> since the transform only works properly if the sampling points are chosen for a particular combination of sample number <span>$N$</span> and aperture size <span>$R$</span>. The workflow to transform a function <span>$f(r)$</span> is therefore as follows:</p><pre><code class="language-julia">j01 = besselj_zero(0, 1)
R = 1
N = 8
q = QDHT(0, R, N)
f(r) = besselj(0, r*j01/R)
fr = f.(q.r)
fk = q * fr # 0th-order QDHT =&gt; fk should have only the first entry non-zero</code></pre><pre><code class="language-none">8-element Array{Float64,1}:
  0.13475706165848392
  4.763728629518283e-10
 -6.08818750247802e-10
  7.28800829543002e-10
 -8.367496368984974e-10
  9.162716080424964e-10
 -9.187255203883264e-10
  7.195637162884995e-10</code></pre><h2 id="Normalisation-1"><a class="docs-heading-anchor" href="#Normalisation-1">Normalisation</a><a class="docs-heading-anchor-permalink" href="#Normalisation-1" title="Permalink"></a></h2><p>The transform as implemented here is unitary, i.e.</p><pre><code class="language-julia">q \ (q * fr) ≈ fr</code></pre><pre><code class="language-none">true</code></pre><p>The transform satisfies <a href="https://en.wikipedia.org/wiki/Parseval%27s_theorem">Parseval&#39;s Theorem</a>. To calculate the <span>$L^2$</span> norm (e.g. energy in a signal) with correct scaling, use <a href="#Hankel.integrateR-Tuple{Any,QDHT}"><code>integrateR</code></a> in real (<span>$r$</span>) space and <a href="#Hankel.integrateK-Tuple{Any,QDHT}"><code>integrateK</code></a> in reciprocal (<span>$k$</span>) space. For an explanation of how these functions work, see the <a href="derivations/#Derivations-1">Derivations</a> page.</p><h2 id="On-axis-and-symmetric-samples-1"><a class="docs-heading-anchor" href="#On-axis-and-symmetric-samples-1">On-axis and symmetric samples</a><a class="docs-heading-anchor-permalink" href="#On-axis-and-symmetric-samples-1" title="Permalink"></a></h2><p>The QDHT does not contain a sample on axis, i.e. at <span>$r=0$</span>, but for the <span>$0^{\mathrm{th}}$</span>-order QDHT, it can be obtained using <a href="#Hankel.onaxis-Union{Tuple{n}, Tuple{Any,QDHT{0,n,T} where T&lt;:Real}} where n"><code>onaxis</code></a>, which takes the <em>transformed</em> array as its input. This is because the on-axis sample is obtained from</p><div>\[f(r=0) = \int_0^\infty \tilde{f}(k) J_0(0) k\,\mathrm{d}k\,.\]</div><p>Note here why this does not work for other values of <span>$p$</span>: <span>$J_p(0) = 0 \; \forall \; p&gt;0$</span>.</p><p>Given an array <code>A</code>, the convenience method <a href="#Hankel.symmetric-Tuple{Any,QDHT}"><code>symmetric</code></a> produces the symmetric array, i.e. given <code>A</code>, sampled at <span>$[r₁, r₂, r₃, ...]$</span>, it generates the array sampled at <span>$[...-r₃, -r₂, -r₁, 0, r₁, r₂, r₃...]$</span>. This works also for higher-dimensional arrays. The corresponding spatial coordinates can be obtained with <a href="#Hankel.Rsymmetric-Tuple{QDHT}"><code>Rsymmetric</code></a>.</p><h2 id="Function-Reference-1"><a class="docs-heading-anchor" href="#Function-Reference-1">Function Reference</a><a class="docs-heading-anchor-permalink" href="#Function-Reference-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Hankel.QDHT" href="#Hankel.QDHT"><code>Hankel.QDHT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QDHT{p, n}(R, N; dim=1)
QDHT([p, ] R, N; dim=1)
QDHT(p, [n, ] R, N; dim=1)</code></pre><p><code>p</code>-th order quasi-discrete Hankel transform over aperture radius <code>R</code> with <code>N</code> samples which transforms along dimension <code>dim</code>. If not given, <code>p</code> defaults to 0, and <code>n</code> the spherical dimension defaults to 1 (cylindrical).</p><p>After:</p><p>[1] L. Yu, M. Huang, M. Chen, W. Chen, W. Huang, and Z. Zhu, Optics Letters 23 (1998)</p><p>[2] M. Guizar-Sicairos and J. C. Gutiérrez-Vega, JOSA A 21, 53 (2004)</p><p>[3] H. F. Johnson, Comput. Phys. Commun., 43, 2 (1987)</p><p>but with some alterations:</p><p>The transform matrix T is not the same as C/T defined in [1, 2] but is more like the form used in equation 14 of [3]. Instead of dividing by <span>$J_1(α_{pn}) J_1(α_{pm})$</span> we divide by <span>$J_1(α_{pn})^2$</span>. This cancels out the factor between <span>$f$</span> and <span>$F$</span> so we do not have to mutltiply (divide) by <span>$J_1(α_{pn})$</span> (<span>$J_1(α_{pm})$</span>) before and after applying the transform matrix.</p><p>Follows <a href="https://github.com/JuliaMath/AbstractFFTs.jl"><code>AbstractFFT</code></a> approach of applying fwd and inv transform with <code>mul</code> and <code>ldiv</code>.</p><p>To calculate radial integrals of functions sampled using <code>QDHT</code>, use <a href="#Hankel.integrateR-Tuple{Any,QDHT}"><code>integrateR</code></a> and <a href="#Hankel.integrateK-Tuple{Any,QDHT}"><code>integrateK</code></a>.</p><p>The type of the coefficients is inferred from the type of <code>R</code> (but is promoted to be at least <code>Float</code>), so for arbitrary precision use <code>QDHT([p, ] BigFloat(R), ...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisbrahms/Hankel.jl/blob/cac7d800872d0eae9af61d49a715882abf85359a/src/qdht.jl#L1-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Hankel.Rsymmetric-Tuple{QDHT}" href="#Hankel.Rsymmetric-Tuple{QDHT}"><code>Hankel.Rsymmetric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Rsymmetric(Q::QDHT)</code></pre><p>Create radial coordinate array to go along with <code>symmetric(A, Q::QDHT)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; q = QDHT{0, 1}(10, 4);
julia&gt; q.r
4-element Array{Float64,1}:
 1.6106347946239767
 3.697078919099734
 5.795844623798052
 7.8973942990196395
julia&gt; Rsymmetric(q)
9-element Array{Float64,1}:
 -7.8973942990196395
 -5.795844623798052
 -3.697078919099734
 -1.6106347946239767
  0.0
  1.6106347946239767
  3.697078919099734
  5.795844623798052
  7.8973942990196395</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisbrahms/Hankel.jl/blob/cac7d800872d0eae9af61d49a715882abf85359a/src/qdht.jl#L319-L345">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Hankel.integrateK-Tuple{Any,QDHT}" href="#Hankel.integrateK-Tuple{Any,QDHT}"><code>Hankel.integrateK</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">integrateK(Ak, Q::QDHT; dim=1)</code></pre><p>Radial integral of <code>A</code>, over the aperture of <code>Q</code> in reciprocal space.</p><p>Assuming <code>A</code> contains samples of a function <code>f(k)</code> at sample points <code>Q.k</code>, then <code>integrateR(A, Q)</code> approximates ∫f(k)k dk from k=0 to k=∞.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>integrateR</code> and <code>integrateK</code> fulfill Parseval&#39;s theorem, i.e. for some array <code>A</code>, <code>integrateR(abs2.(A), q)</code> and <code>integrateK(abs2.(q*A), q)</code> are equal, <strong>but</strong> <code>integrateR(A, q)</code> and <code>integrateK(q*A, q)</code> are <strong>not</strong> equal.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; q = QDHT{0, 1}(10, 128); A = exp.(-q.r.^2/2);
julia&gt; integrateR(abs2.(A), q) ≈ 0.5 # analytical solution of ∫exp(-r²)r dr from 0 to ∞
true
julia&gt; Ak = q*A;
julia&gt; integrateK(abs2.(Ak), q) ≈ 0.5 # Same result
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisbrahms/Hankel.jl/blob/cac7d800872d0eae9af61d49a715882abf85359a/src/qdht.jl#L239-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Hankel.integrateR-Tuple{Any,QDHT}" href="#Hankel.integrateR-Tuple{Any,QDHT}"><code>Hankel.integrateR</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">integrateR(A, Q::QDHT; dim=1)</code></pre><p>Radial integral of <code>A</code>, over the aperture of <code>Q</code> in real space.</p><p>Assuming <code>A</code> contains samples of a function <code>f(r)</code> at sample points <code>Q.r</code>, then <code>integrateR(A, Q)</code> approximates ∫f(r)r dr from r=0 to r=∞.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>integrateR</code> and <code>integrateK</code> fulfill Parseval&#39;s theorem, i.e. for some array <code>A</code>, <code>integrateR(abs2.(A), q)</code> and <code>integrateK(abs2.(q*A), q)</code> are equal, <strong>but</strong> <code>integrateR(A, q)</code> and <code>integrateK(q*A, q)</code> are <strong>not</strong> equal.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>using <code>integrateR</code> to integrate a function (i.e. <code>A</code> rather than <code>abs2(A)</code>) is only supported for the 0th-order QDHT. For more details see <a href="derivations/#Derivations-1">Derivations</a>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; q = QDHT{0, 1}(10, 128); A = exp.(-q.r.^2/2);
julia&gt; integrateR(abs2.(A), q) ≈ 0.5 # analytical solution of ∫exp(-r²)r dr from 0 to ∞
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisbrahms/Hankel.jl/blob/cac7d800872d0eae9af61d49a715882abf85359a/src/qdht.jl#L213-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Hankel.onaxis-Union{Tuple{n}, Tuple{Any,QDHT{0,n,T} where T&lt;:Real}} where n" href="#Hankel.onaxis-Union{Tuple{n}, Tuple{Any,QDHT{0,n,T} where T&lt;:Real}} where n"><code>Hankel.onaxis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">onaxis(Ak, Q::QDHT; dim=Q.dim)</code></pre><p>Calculate on-axis sample in space (i.e. at r=0) from transformed array <code>Ak</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>onaxis</code> is currently only supported for 0-order transforms</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; q = QDHT{0, 1}(10, 128); A = exp.(-q.r.^2/2);
julia&gt; onaxis(q*A, q) ≈ 1 # should be exp(0) = 1
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisbrahms/Hankel.jl/blob/cac7d800872d0eae9af61d49a715882abf85359a/src/qdht.jl#L265-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Hankel.symmetric-Tuple{Any,QDHT}" href="#Hankel.symmetric-Tuple{Any,QDHT}"><code>Hankel.symmetric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">symmetric(A, Q::QDHT)</code></pre><p>Create symmetric array from samples in <code>A</code>, including on-axis sample.</p><p>Given <code>A</code>, sampled at <code>[r₁, r₂, r₃, ...]</code>, generates array sampled at <code>[...-r₃, -r₂, -r₁, 0, r₁, r₂, r₃...]</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; q = QDHT{0, 1}(10, 128); A = exp.(-q.r.^2);
julia&gt; As = symmetric(A, q);
julia&gt; size(As)
(257,)
julia&gt; As[1:128] == A[128:-1:1]
true
julia&gt; As[129] ≈ 1 # should be exp(0) = 1
true
julia&gt; As[130:end] == A
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisbrahms/Hankel.jl/blob/cac7d800872d0eae9af61d49a715882abf85359a/src/qdht.jl#L286-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{QDHT,Any}" href="#Base.:*-Tuple{QDHT,Any}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">*(Q::QDHT, A)</code></pre><p>Calculate the forward quasi-discrete Hankel transform of array <code>A</code> using the QDHT <code>Q</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; q = QDHT{0, 1}(1e-2, 8); A = exp.(-q.r.^2/(1e-3*q.R));
julia&gt; q*A
8-element Array{Float64,1}:
  4.326937831591551e-6
  2.3341589529175126e-6
  7.689558743828849e-7
  1.546419420523699e-7
  1.8999259906096856e-8
  1.4159642663129888e-9
  7.013670190083954e-11
 -6.07681871673291e-13</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisbrahms/Hankel.jl/blob/cac7d800872d0eae9af61d49a715882abf85359a/src/qdht.jl#L170-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:\\-Tuple{QDHT,Any}" href="#Base.:\\-Tuple{QDHT,Any}"><code>Base.:\</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">\(Q::QDHT, A)</code></pre><p>Calculate the inverse quasi-discrete Hankel transform of array <code>A</code> using the QDHT <code>Q</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; q = QDHT{0, 1}(1e-2, 8); A = exp.(-q.r.^2/(1e-3*q.R));
julia&gt; Ak = q*A;
julia&gt; q \ Ak ≈ A
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisbrahms/Hankel.jl/blob/cac7d800872d0eae9af61d49a715882abf85359a/src/qdht.jl#L195-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.inv-Union{Tuple{T}, Tuple{T}} where T&lt;:QDHT" href="#Base.inv-Union{Tuple{T}, Tuple{T}} where T&lt;:QDHT"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inv(Q::QDHT) -&gt; QDHT</code></pre><p>Compute the <code>QDHT</code> for the inverse of the Hankel transform <code>Q</code>, that is, the transform such that <code>Q * A == inv(Q) \ A</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisbrahms/Hankel.jl/blob/cac7d800872d0eae9af61d49a715882abf85359a/src/qdht.jl#L91-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reshape-Union{Tuple{n}, Tuple{p}, Tuple{QDHT{p,n,T} where T&lt;:Real,Int64}} where n where p" href="#Base.reshape-Union{Tuple{n}, Tuple{p}, Tuple{QDHT{p,n,T} where T&lt;:Real,Int64}} where n where p"><code>Base.reshape</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reshape(Q::QDHT, N::Int) -&gt; QDHT</code></pre><p>Compute a new <code>QDHT</code> with the same order, spherical dimension, and radius but with <code>N</code> points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisbrahms/Hankel.jl/blob/cac7d800872d0eae9af61d49a715882abf85359a/src/qdht.jl#L113-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Hankel.dimdot-Tuple{Any,Any}" href="#Hankel.dimdot-Tuple{Any,Any}"><code>Hankel.dimdot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dimdot(v, A; dim=1)</code></pre><p>Calculate the dot product between vector <code>v</code> and one dimension of array <code>A</code>, iterating over all other dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisbrahms/Hankel.jl/blob/cac7d800872d0eae9af61d49a715882abf85359a/src/utils.jl#L80-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Hankel.dot!-Tuple{Any,Any,AbstractArray{T,1} where T}" href="#Hankel.dot!-Tuple{Any,Any,AbstractArray{T,1} where T}"><code>Hankel.dot!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dot!(out, M, V; dim=1)</code></pre><p>Matrix-vector multiplication along specific dimension of array <code>V</code>, storing result in <code>out</code>.</p><p>This is equivalent to iterating over all dimensions of <code>V</code> other than <code>dim</code> and applying the matrix-vector multiplication <code>M * v[..., :, ...]</code>, but works by reshaping the array if necessary to take advantage of faster matrix-matrix multiplication. If <code>dim==1</code>, <code>dot!</code> is fastest and allocation-free.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisbrahms/Hankel.jl/blob/cac7d800872d0eae9af61d49a715882abf85359a/src/utils.jl#L17-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Hankel.order-Union{Tuple{QDHT{p,n,T} where T&lt;:Real where n}, Tuple{p}} where p" href="#Hankel.order-Union{Tuple{QDHT{p,n,T} where T&lt;:Real where n}, Tuple{p}} where p"><code>Hankel.order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">order(q::QDHT)</code></pre><p>Order of transform <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisbrahms/Hankel.jl/blob/cac7d800872d0eae9af61d49a715882abf85359a/src/qdht.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Hankel.oversample-Tuple{Any,QDHT}" href="#Hankel.oversample-Tuple{Any,QDHT}"><code>Hankel.oversample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">oversample(A, Q::QDHT; factor::Int=4) -&gt; Tuple{AbstractArray,QDHT}
oversample(A, Q::QDHT, QNew::QDHT) -&gt; AbstractArray</code></pre><p>Oversample (smooth) the array <code>A</code>, which is sampled with the <code>QDHT</code> <code>Q</code>, by a <code>factor</code>.</p><p>If calling the function many times, it is more efficient to precompute <code>QNew</code> with <a href="#Base.reshape-Union{Tuple{n}, Tuple{p}, Tuple{QDHT{p,n,T} where T&lt;:Real,Int64}} where n where p"><code>reshape</code></a> and then provide it to the function.</p><p>This works like Fourier-domain zero-padding: a new <code>QDHT</code> is created with the same radius, but <code>factor</code> times more points. The existing array is transformed and placed onto this new spatial frequency grid, and the rest filled with zeros. Transforming back yields the same shape in space but with more samples.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Unlike in zero-padding using FFTs, the old and oversampled <strong>spatial</strong> grids do not have any sampling points in common.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisbrahms/Hankel.jl/blob/cac7d800872d0eae9af61d49a715882abf85359a/src/qdht.jl#L348-L365">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Hankel.padzeros-Tuple{Any,Any}" href="#Hankel.padzeros-Tuple{Any,Any}"><code>Hankel.padzeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">padzeros(A, N; dim = 1)</code></pre><p>Pad array <code>A</code> with zeros to length <code>N</code> along dimension <code>dim</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisbrahms/Hankel.jl/blob/cac7d800872d0eae9af61d49a715882abf85359a/src/utils.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Hankel.sphbesselj-Tuple{Any,Any,Any}" href="#Hankel.sphbesselj-Tuple{Any,Any,Any}"><code>Hankel.sphbesselj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sphbesselj(p, n, x)</code></pre><p>(Hyper)spherical Bessel function of order <span>$p$</span> and spherical dimension <span>$n$</span>. The hyperspherical Bessel function generalizes the cylindrical and spherical Bessel functions to the <span>$n$</span>-sphere (embedded in <span>$ℝ^{n+1}$</span>). It is given as</p><div>\[j_p^{n}(x) = c_n x^{-(n-1)/2} J_{p + (n-1)/2}(x),\]</div><p>where <span>$c_n$</span> is a normalization factor defined by <a href="#Hankel.sphbesselj_scale-Tuple{Any}"><code>sphbesselj_scale</code></a>. Note that <span>$n$</span> is not an exponent here.</p><p>It has as its special cases:</p><ul><li>Cylindrical Bessel function (<span>$n=1$</span>): <span>$j_p^{1}(x) = J_p(x)$</span></li><li>Spherical Bessel function (<span>$n=2$</span>): <span>$j_p^{2}(x) = j_p(x)$</span></li></ul><p>After:</p><p>[1] J. S. Avery, J. E. Avery. Hyperspherical Harmonics And Their Physical Applications.     Singapore: World Scientific Publishing Company, 2017.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisbrahms/Hankel.jl/blob/cac7d800872d0eae9af61d49a715882abf85359a/src/utils.jl#L126-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Hankel.sphbesselj_scale-Tuple{Any}" href="#Hankel.sphbesselj_scale-Tuple{Any}"><code>Hankel.sphbesselj_scale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sphbesselj_scale(n)</code></pre><p>Return the normalization factor for the (hyper)spherical Bessel function (<a href="#Hankel.sphbesselj-Tuple{Any,Any,Any}"><code>sphbesselj</code></a>) with spherical dimension <span>$n$</span>, given as <span>$c_n = \sqrt{\frac{π}{2}}$</span> for even <span>$n$</span> and 1 otherwise.</p><p>After:</p><p>[1] J. S. Avery, J. E. Avery. Hyperspherical Harmonics And Their Physical Applications.     Singapore: World Scientific Publishing Company, 2017.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisbrahms/Hankel.jl/blob/cac7d800872d0eae9af61d49a715882abf85359a/src/utils.jl#L112-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Hankel.sphbesselj_zero-Tuple{Any,Any,Any}" href="#Hankel.sphbesselj_zero-Tuple{Any,Any,Any}"><code>Hankel.sphbesselj_zero</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sphbesselj_zero(p, n, m)</code></pre><p>Get the <span>$m$</span>th zero of the (hyper)spherical Bessel function of order <span>$p$</span> and spherical dimension <span>$n$</span>.</p><p>See <a href="#Hankel.sphbesselj-Tuple{Any,Any,Any}"><code>sphbesselj</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisbrahms/Hankel.jl/blob/cac7d800872d0eae9af61d49a715882abf85359a/src/utils.jl#L166-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Hankel.sphericaldim-Union{Tuple{QDHT{p,n,T} where T&lt;:Real}, Tuple{n}, Tuple{p}} where n where p" href="#Hankel.sphericaldim-Union{Tuple{QDHT{p,n,T} where T&lt;:Real}, Tuple{n}, Tuple{p}} where n where p"><code>Hankel.sphericaldim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sphericaldim(q::QDHT)</code></pre><p>Spherical dimension <span>$n$</span> of transform <code>q</code>.</p><p>Dimension of the <span>$n$</span>-sphere over whose radial coordinate the bases of the transform <code>q</code> are orthogonal polynomials. For the circle, <span>$n=1$</span>, and for the sphere, <span>$n=2$</span>.</p><p>See <a href="#Hankel.sphbesselj-Tuple{Any,Any,Any}"><code>sphbesselj</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisbrahms/Hankel.jl/blob/cac7d800872d0eae9af61d49a715882abf85359a/src/qdht.jl#L79-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.ldiv!-Tuple{Any,QDHT,Any}" href="#LinearAlgebra.ldiv!-Tuple{Any,QDHT,Any}"><code>LinearAlgebra.ldiv!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ldiv!(Y, Q::QDHT, A)</code></pre><p>Calculate the inverse quasi-discrete Hankel transform of array <code>A</code> using the QDHT <code>Q</code> and store the result in <code>Y</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; q = QDHT{0, 1}(1e-2, 8); A = exp.(-q.r.^2/(1e-3*q.R)); Y = similar(A);
julia&gt; mul!(Y, q, A);
julia&gt; YY = similar(Y); ldiv!(YY, q, Y);
julia&gt; YY ≈ A
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisbrahms/Hankel.jl/blob/cac7d800872d0eae9af61d49a715882abf85359a/src/qdht.jl#L150-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.mul!-Tuple{Any,QDHT,Any}" href="#LinearAlgebra.mul!-Tuple{Any,QDHT,Any}"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mul!(Y, Q::QDHT, A)</code></pre><p>Calculate the forward quasi-discrete Hankel transform of array <code>A</code> using the QDHT <code>Q</code> and store the result in <code>Y</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; q = QDHT{0, 1}(1e-2, 8); A = exp.(-q.r.^2/(1e-3*q.R)); Y = similar(A);
julia&gt; mul!(Y, q, A)
8-element Array{Float64,1}:
  4.326937831591551e-6
  2.3341589529175126e-6
  7.689558743828849e-7
  1.546419420523699e-7
  1.8999259906096856e-8
  1.4159642663129888e-9
  7.013670190083954e-11
 -6.07681871673291e-13</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisbrahms/Hankel.jl/blob/cac7d800872d0eae9af61d49a715882abf85359a/src/qdht.jl#L124-L145">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="derivations/">Derivations »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 24 June 2020 08:25">Wednesday 24 June 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
