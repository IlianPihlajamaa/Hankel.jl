<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Hankel · Hankel</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Hankel</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Hankel</a><ul class="internal"><li><a class="tocitem" href="#Normalisation-1"><span>Normalisation</span></a></li><li><a class="tocitem" href="#On-axis-and-symmetric-samples-1"><span>On-axis and symmetric samples</span></a></li><li><a class="tocitem" href="#Function-Reference-1"><span>Function Reference</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Hankel</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Hankel</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/chrisbrahms/Hankel/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Hankel-1"><a class="docs-heading-anchor" href="#Hankel-1">Hankel</a><a class="docs-heading-anchor-permalink" href="#Hankel-1" title="Permalink"></a></h1><p><code>Hankel</code> implements the <span>$0^{\mathrm{th}}$</span>-order quasi-discrete Hankel transform (QDHT) as first laid out in <a href="https://www.osapublishing.org/ol/abstract.cfm?uri=ol-23-6-409">L. Yu, <em>et al.</em>, Optics Letters 23 (1998)</a>. The forward <span>$0^{\mathrm{th}}$</span>-order Hankel transform of the radially symmetric function <span>$f(r)$</span> is defined as</p><div>\[\tilde{f}(k) = \int_0^\infty f(r) J_0(kr) r\,\mathrm{d}r\,,\]</div><p>where <span>$J_0(x)$</span> is the <span>$0^{\mathrm{th}}$</span>-order Bessel function of the first kind. Correspondingly, the inverse transform is</p><div>\[f(r) = \int_0^\infty \tilde{f}(k) J_0(kr) k\,\mathrm{d}k\,.\]</div><p>Note that here, <span>$k$</span> includes the factor of <span>$2\pi$</span>, i.e. it is spatial angular frequency.</p><p>The QDHT approximates these transforms under the assumption that <span>$f(r) = 0$</span> for <span>$r &gt; R$</span> where <span>$R$</span> is the aperture size. By expanding <span>$f(r)$</span> as a Fourier-Bessel series and choosing to sample <span>$f(r)$</span> at coordinates <span>$r_n = j_nR/j_{N+1}$</span>, where <span>$j_n$</span> is the <span>$n^{\mathrm{th}}$</span> zero of <span>$J_0(x)$</span> and <span>$N$</span> is the number of samples, the Hankel transform turns into a matrix-vector multiplication.</p><p><code>Hankel</code> follows the <a href="https://juliamath.github.io/AbstractFFTs.jl/stable/"><code>AbstractFFTs</code></a> approach of planning a transform in advance by creating a <a href="#Hankel.QDHT"><code>QDHT</code></a> object, which can then be used to transform an array using multiplication (<a href="#Base.:*-Tuple{QDHT,Any}"><code>*</code></a> or <a href="#LinearAlgebra.mul!-Tuple{Any,QDHT,Any}"><code>mul!</code></a>) and to transform back by left-division (<a href="#Base.:\\-Tuple{QDHT,Any}"><code>\</code></a> or <a href="#LinearAlgebra.ldiv!-Tuple{Any,QDHT,Any}"><code>ldiv!</code></a>). In contrast to <code>AbstractFFTs</code>, however, <strong>pre-planning a transform is required</strong> since the transform only works properly if the sampling points are chosen for a particular combination of sample number <span>$N$</span> and aperture size <span>$R$</span>. The workflow to transform a function <span>$f(r)$</span> is therefore as follows:</p><pre><code class="language-julia">j01 = besselj_zero(0, 1)
R = 1
N = 8
q = QDHT(R, N)
f(r) = besselj(0, r*j01/R)
fr = f.(q.r)
fk = q * fr # fk should have only the first entry non-zero</code></pre><pre><code class="language-none">8-element Array{Float64,1}:
  0.13475706165848392
  4.763728629518283e-10
 -6.08818750247802e-10
  7.28800829543002e-10
 -8.367496368984974e-10
  9.162716080424964e-10
 -9.187255203883264e-10
  7.195637162884995e-10</code></pre><h2 id="Normalisation-1"><a class="docs-heading-anchor" href="#Normalisation-1">Normalisation</a><a class="docs-heading-anchor-permalink" href="#Normalisation-1" title="Permalink"></a></h2><p>The transform as implemented here is unitary, i.e.</p><pre><code class="language-julia">q \ (q * fr) ≈ fr</code></pre><pre><code class="language-none">true</code></pre><p>To avoid unnecessary multiplications, the transform matrix (<span>$C$</span> in Yu <em>et al.</em>, here it&#39;s called <code>T</code>) is altered slightly (see <a href="#Hankel.QDHT"><code>QDHT</code></a>), and as a consequence the transformation itself does not conserve energy (i.e. satisfy <a href="https://en.wikipedia.org/wiki/Parseval%27s_theorem">Parseval&#39;s Theorem</a>). To calculate the <span>$L^2$</span> norm (e.g. energy in a signal) with correct scaling, using <a href="#Hankel.integrateR-Tuple{Any,QDHT}"><code>integrateR</code></a> in real (<span>$r$</span>) space and <a href="#Hankel.integrateK-Tuple{Any,QDHT}"><code>integrateK</code></a> in reciprocal (<span>$k$</span>) space.</p><h2 id="On-axis-and-symmetric-samples-1"><a class="docs-heading-anchor" href="#On-axis-and-symmetric-samples-1">On-axis and symmetric samples</a><a class="docs-heading-anchor-permalink" href="#On-axis-and-symmetric-samples-1" title="Permalink"></a></h2><p>The QDHT does not contain a sample on axis, i.e. at <span>$r=0$</span>, but it can be obtained.</p><h2 id="Function-Reference-1"><a class="docs-heading-anchor" href="#Function-Reference-1">Function Reference</a><a class="docs-heading-anchor-permalink" href="#Function-Reference-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Hankel.QDHT" href="#Hankel.QDHT"><code>Hankel.QDHT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QDHT(R, N; dim=1)</code></pre><p>Quasi-discrete Hankel transform over aperture radius <code>R</code> with <code>N</code> samples which transforms along dimension <code>dim</code></p><p>After:</p><p>[1] L. Yu, M. Huang, M. Chen, W. Chen, W. Huang, and Z. Zhu, Optics Letters 23 (1998)</p><p>[2] M. Guizar-Sicairos and J. C. Gutiérrez-Vega, JOSA A 21, 53 (2004)</p><p>but with some alterations:</p><p>The transform matrix T is not the same as C/T defined in [1, 2]. Instead of dividing by J₁(αₚₙ)J₁(αₚₘ) we divide by J₁(αₚₙ)^2. This cancels out the factor between f and F so we do not have to mutltiply (divide) by J₁(αₚₙ) (J₁(αₚₘ)) before and after applying the transform matrix. This means T is not symmetric, and does not conserve energy. To conserve energy, use <code>integrateR</code> and <code>integrateK</code>.</p><p>Follows <code>AbstractFFT</code> approach of applying fwd and inv transform with <code>mul</code> and <code>ldiv</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisbrahms/Hankel/blob/3fe2a99496b64dab1a496b9f1432d023fe254675/src/Hankel.jl#L11-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.mul!-Tuple{Any,QDHT,Any}" href="#LinearAlgebra.mul!-Tuple{Any,QDHT,Any}"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mul!(Y, Q::QDHT, A)</code></pre><p>Calculate the forward quasi-discrete Hankel transform of array <code>A</code> using the QDHT <code>Q</code> and store the result in <code>Y</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; q = QDHT(1e-2, 8); A = exp.(-q.r.^2/(1e-3*q.R)); Y = similar(A);
julia&gt; mul!(Y, q, A)
8-element Array{Float64,1}:
  4.326937831591551e-6
  2.3341589529175126e-6
  7.689558743828849e-7
  1.546419420523699e-7
  1.8999259906096856e-8
  1.4159642663129888e-9
  7.013670190083954e-11
 -6.07681871673291e-13</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisbrahms/Hankel/blob/3fe2a99496b64dab1a496b9f1432d023fe254675/src/Hankel.jl#L61-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.ldiv!-Tuple{Any,QDHT,Any}" href="#LinearAlgebra.ldiv!-Tuple{Any,QDHT,Any}"><code>LinearAlgebra.ldiv!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ldiv!(Y, Q::QDHT, A)</code></pre><p>Calculate the inverse quasi-discrete Hankel transform of array <code>A</code> using the QDHT <code>Q</code> and store the result in <code>Y</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; q = QDHT(1e-2, 8); A = exp.(-q.r.^2/(1e-3*q.R)); Y = similar(A);
julia&gt; mul!(Y, q, A);
julia&gt; YY = similar(Y); ldiv!(YY, q, Y);
julia&gt; YY ≈ A
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisbrahms/Hankel/blob/3fe2a99496b64dab1a496b9f1432d023fe254675/src/Hankel.jl#L87-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{QDHT,Any}" href="#Base.:*-Tuple{QDHT,Any}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">*(Q::QDHT, A)</code></pre><p>Calculate the forward quasi-discrete Hankel transform of array <code>A</code> using the QDHT <code>Q</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; q = QDHT(1e-2, 8); A = exp.(-q.r.^2/(1e-3*q.R));
julia&gt; q*A
8-element Array{Float64,1}:
  4.326937831591551e-6
  2.3341589529175126e-6
  7.689558743828849e-7
  1.546419420523699e-7
  1.8999259906096856e-8
  1.4159642663129888e-9
  7.013670190083954e-11
 -6.07681871673291e-13</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisbrahms/Hankel/blob/3fe2a99496b64dab1a496b9f1432d023fe254675/src/Hankel.jl#L107-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:\\-Tuple{QDHT,Any}" href="#Base.:\\-Tuple{QDHT,Any}"><code>Base.:\</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">\(Q::QDHT, A)</code></pre><p>Calculate the inverse quasi-discrete Hankel transform of array <code>A</code> using the QDHT <code>Q</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; q = QDHT(1e-2, 8); A = exp.(-q.r.^2/(1e-3*q.R));
julia&gt; Ak = q*A;
julia&gt; q \ Ak ≈ A
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisbrahms/Hankel/blob/3fe2a99496b64dab1a496b9f1432d023fe254675/src/Hankel.jl#L132-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Hankel.integrateR-Tuple{Any,QDHT}" href="#Hankel.integrateR-Tuple{Any,QDHT}"><code>Hankel.integrateR</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">integrateR(A, Q::QDHT; dim=1)</code></pre><p>Radial integral of <code>A</code>, over the aperture of <code>Q</code> in real space.</p><p>Assuming <code>A</code> contains samples of a function <code>f(r)</code> at sample points <code>Q.r</code>, then <code>integrateR(A, Q)</code> approximates ∫f(r)r dr from r=0 to r=∞.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>integrateR</code> and <code>integrateK</code> fulfill Parseval&#39;s theorem, i.e. for some array <code>A</code>, <code>integrateR(abs2.(A), q)</code> and <code>integrateK(abs2.(q*A), q)</code> are equal, <strong>but</strong>  <code>integrateR(A, q)</code> and <code>integrateK(q*A, q)</code> are <strong>not</strong> equal.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; q = QDHT(10, 128); A = exp.(-q.r.^2/2);
julia&gt; integrateR(abs2.(A), q) ≈ 0.5 # analytical solution of ∫exp(-r²)r dr from 0 to ∞
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisbrahms/Hankel/blob/3fe2a99496b64dab1a496b9f1432d023fe254675/src/Hankel.jl#L150-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Hankel.integrateK-Tuple{Any,QDHT}" href="#Hankel.integrateK-Tuple{Any,QDHT}"><code>Hankel.integrateK</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">integrateK(Ak, Q::QDHT; dim=1)</code></pre><p>Radial integral of <code>A</code>, over the aperture of <code>Q</code> in reciprocal space.</p><p>Assuming <code>A</code> contains samples of a function <code>f(k)</code> at sample points <code>Q.k</code>, then <code>integrateR(A, Q)</code> approximates ∫f(k)k dk from k=0 to k=∞.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>integrateR</code> and <code>integrateK</code> fulfill Parseval&#39;s theorem, i.e. for some array <code>A</code>, <code>integrateR(abs2.(A), q)</code> and <code>integrateK(abs2.(q*A), q)</code> are equal, <strong>but</strong>  <code>integrateR(A, q)</code> and <code>integrateK(q*A, q)</code> are <strong>not</strong> equal.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; q = QDHT(10, 128); A = exp.(-q.r.^2/2);
julia&gt; integrateR(abs2.(A), q) ≈ 0.5 # analytical solution of ∫exp(-r²)r dr from 0 to ∞
true
julia&gt; Ak = q*A;
julia&gt; integrateK(abs2.(Ak), q) ≈ 0.5 # Same result
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisbrahms/Hankel/blob/3fe2a99496b64dab1a496b9f1432d023fe254675/src/Hankel.jl#L172-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Hankel.onaxis-Tuple{Any,QDHT}" href="#Hankel.onaxis-Tuple{Any,QDHT}"><code>Hankel.onaxis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">onaxis(Ak, Q::QDHT; dim=Q.dim)</code></pre><p>Calculate on-axis sample in space (i.e. at r=0) from transformed array <code>Ak</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; q = QDHT(10, 128); A = exp.(-q.r.^2/2);
julia&gt; onaxis(q*A, q) ≈ 1 # should be exp(0) = 1
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisbrahms/Hankel/blob/3fe2a99496b64dab1a496b9f1432d023fe254675/src/Hankel.jl#L198-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Hankel.symmetric-Tuple{Any,QDHT}" href="#Hankel.symmetric-Tuple{Any,QDHT}"><code>Hankel.symmetric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">symmetric(A, Q::QDHT)</code></pre><p>Create symmetric array from samples in <code>A</code>, including on-axis sample.</p><p>Given <code>A</code>, sampled at [r₁, r₂, r₃, ...], generates array sampled at  [...-r₃, -r₂, -r₁, 0, r₁, r₂, r₃...]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; q = QDHT(10, 128); A = exp.(-q.r.^2);
julia&gt; As = symmetric(A, q);
julia&gt; size(As)
(257,)
julia&gt; As[1:128] == A[128:-1:1]
true
julia&gt; As[129] ≈ 1 # should be exp(0) = 1
true
julia&gt; As[130:end] == A
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisbrahms/Hankel/blob/3fe2a99496b64dab1a496b9f1432d023fe254675/src/Hankel.jl#L212-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Hankel.Rsymmetric-Tuple{QDHT}" href="#Hankel.Rsymmetric-Tuple{QDHT}"><code>Hankel.Rsymmetric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Rsymmetric(Q::QDHT)</code></pre><p>Create radial coordinate array to go along with <code>symmetric(A, Q::QDHT)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; q = QDHT(10, 4);
julia&gt; q.r
4-element Array{Float64,1}:
 1.6106347946239767
 3.697078919099734
 5.795844623798052
 7.8973942990196395
julia&gt; Rsymmetric(q)
9-element Array{Float64,1}:
 -7.8973942990196395
 -5.795844623798052
 -3.697078919099734
 -1.6106347946239767
  0.0
  1.6106347946239767
  3.697078919099734
  5.795844623798052
  7.8973942990196395</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisbrahms/Hankel/blob/3fe2a99496b64dab1a496b9f1432d023fe254675/src/Hankel.jl#L256-L282">source</a></section></article></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 30 March 2020 15:09">Monday 30 March 2020</span>. Using Julia version 1.4.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
