var documenterSearchIndex = {"docs":
[{"location":"#Hankel-1","page":"Hankel","title":"Hankel","text":"","category":"section"},{"location":"#","page":"Hankel","title":"Hankel","text":"Hankel implements the 0^mathrmth-order quasi-discrete Hankel transform (QDHT) as first laid out in L. Yu, et al., Optics Letters 23 (1998). The forward 0^mathrmth-order Hankel transform of the radially symmetric function f(r) is defined as","category":"page"},{"location":"#","page":"Hankel","title":"Hankel","text":"tildef(k) = int_0^infty f(r) J_0(kr) rmathrmdr","category":"page"},{"location":"#","page":"Hankel","title":"Hankel","text":"where J_0(x) is the 0^mathrmth-order Bessel function of the first kind. Correspondingly, the inverse transform is","category":"page"},{"location":"#","page":"Hankel","title":"Hankel","text":"f(r) = int_0^infty tildef(k) J_0(kr) kmathrmdk","category":"page"},{"location":"#","page":"Hankel","title":"Hankel","text":"Note that here, k includes the factor of 2pi, i.e. it is spatial angular frequency.","category":"page"},{"location":"#","page":"Hankel","title":"Hankel","text":"The QDHT approximates these transforms under the assumption that f(r) = 0 for r  R where R is the aperture size. By expanding f(r) as a Fourier-Bessel series and choosing to sample f(r) at coordinates r_n = j_nRj_N+1, where j_n is the n^mathrmth zero of J_0(x) and N is the number of samples, the Hankel transform turns into a matrix-vector multiplication.","category":"page"},{"location":"#","page":"Hankel","title":"Hankel","text":"Hankel follows the AbstractFFTs approach of planning a transform in advance by creating a QDHT object, which can then be used to transform an array using multiplication (* or mul!) and to transform back by left-division (\\ or ldiv!). In contrast to AbstractFFTs, however, pre-planning a transform is required since the transform only works properly if the sampling points are chosen for a particular combination of sample number N and aperture size R. The workflow to transform a function f(r) is therefore as follows:","category":"page"},{"location":"#","page":"Hankel","title":"Hankel","text":"using Hankel # hide\nimport Hankel: besselj_zero, besselj # hide\nj01 = besselj_zero(0, 1)\nR = 1\nN = 8\nq = QDHT(R, N)\nf(r) = besselj(0, r*j01/R)\nfr = f.(q.r)\nfk = q * fr # fk should have only the first entry non-zero","category":"page"},{"location":"#Normalisation-1","page":"Hankel","title":"Normalisation","text":"","category":"section"},{"location":"#","page":"Hankel","title":"Hankel","text":"The transform as implemented here is unitary, i.e.","category":"page"},{"location":"#","page":"Hankel","title":"Hankel","text":"using Hankel # hide\nimport Hankel: besselj_zero, besselj # hide\nj01 = besselj_zero(0, 1) # hide\nR = 1 # hide\nN = 512 # hide\nq = QDHT(R, N) # hide\nf(r) = besselj(0, r*j01/R) # hide\nfr = f.(q.r) # hide\nq \\ (q * fr) ≈ fr","category":"page"},{"location":"#","page":"Hankel","title":"Hankel","text":"To avoid unnecessary multiplications, the transform matrix (C in Yu et al., here it's called T) is altered slightly (see QDHT), and as a consequence the transformation itself does not conserve energy (i.e. satisfy Parseval's Theorem). To calculate the L^2 norm (e.g. energy in a signal) with correct scaling, use integrateR in real (r) space and integrateK in reciprocal (k) space.","category":"page"},{"location":"#On-axis-and-symmetric-samples-1","page":"Hankel","title":"On-axis and symmetric samples","text":"","category":"section"},{"location":"#","page":"Hankel","title":"Hankel","text":"The QDHT does not contain a sample on axis, i.e. at r=0, but it can be obtained using onaxis, which takes the transformed array as its input. This is because the on-axis sample is obtained from","category":"page"},{"location":"#","page":"Hankel","title":"Hankel","text":"f(r=0) = int_0^infty tildef(k) J_0(0) kmathrmdk","category":"page"},{"location":"#","page":"Hankel","title":"Hankel","text":"Given an array A, the convenience method symmetric produces the symmetric array, i.e. given A, sampled at r₁ r₂ r₃ , it generates the array sampled at -r₃ -r₂ -r₁ 0 r₁ r₂ r₃. This works also for higher-dimensional arrays. The corresponding spatial coordinates can be obtained with Rsymmetric.","category":"page"},{"location":"#Function-Reference-1","page":"Hankel","title":"Function Reference","text":"","category":"section"},{"location":"#","page":"Hankel","title":"Hankel","text":"Modules = [Hankel]","category":"page"},{"location":"#Hankel.QDHT","page":"Hankel","title":"Hankel.QDHT","text":"QDHT(R, N; dim=1)\n\nQuasi-discrete Hankel transform over aperture radius R with N samples which transforms along dimension dim.\n\nAfter:\n\n[1] L. Yu, M. Huang, M. Chen, W. Chen, W. Huang, and Z. Zhu, Optics Letters 23 (1998)\n\n[2] M. Guizar-Sicairos and J. C. Gutiérrez-Vega, JOSA A 21, 53 (2004)\n\nbut with some alterations:\n\nThe transform matrix T is not the same as C/T defined in [1, 2]. Instead of dividing by J₁(αₚₙ)J₁(αₚₘ) we divide by J₁(αₚₙ)^2. This cancels out the factor between f and F so we do not have to mutltiply (divide) by J₁(αₚₙ) (J₁(αₚₘ)) before and after applying the transform matrix. This means T is not symmetric, and does not conserve energy. To conserve energy, use integrateR and integrateK.\n\nFollows AbstractFFT approach of applying fwd and inv transform with mul and ldiv.\n\nThe type of the coefficients is inferred from the type of R (but is promoted to be at least Float), so for arbitrary precision use QDHT(BigFloat(R), ...).\n\n\n\n\n\n","category":"type"},{"location":"#Hankel.Rsymmetric-Tuple{QDHT}","page":"Hankel","title":"Hankel.Rsymmetric","text":"Rsymmetric(Q::QDHT)\n\nCreate radial coordinate array to go along with symmetric(A, Q::QDHT).\n\nExamples\n\njulia> q = QDHT(10, 4);\njulia> q.r\n4-element Array{Float64,1}:\n 1.6106347946239767\n 3.697078919099734\n 5.795844623798052\n 7.8973942990196395\njulia> Rsymmetric(q)\n9-element Array{Float64,1}:\n -7.8973942990196395\n -5.795844623798052\n -3.697078919099734\n -1.6106347946239767\n  0.0\n  1.6106347946239767\n  3.697078919099734\n  5.795844623798052\n  7.8973942990196395\n\n\n\n\n\n","category":"method"},{"location":"#Hankel.integrateK-Tuple{Any,QDHT}","page":"Hankel","title":"Hankel.integrateK","text":"integrateK(Ak, Q::QDHT; dim=1)\n\nRadial integral of A, over the aperture of Q in reciprocal space.\n\nAssuming A contains samples of a function f(k) at sample points Q.k, then integrateR(A, Q) approximates ∫f(k)k dk from k=0 to k=∞.\n\nnote: Note\nintegrateR and integrateK fulfill Parseval's theorem, i.e. for some array A, integrateR(abs2.(A), q) and integrateK(abs2.(q*A), q) are equal, but  integrateR(A, q) and integrateK(q*A, q) are not equal.\n\nExamples\n\njulia> q = QDHT(10, 128); A = exp.(-q.r.^2/2);\njulia> integrateR(abs2.(A), q) ≈ 0.5 # analytical solution of ∫exp(-r²)r dr from 0 to ∞\ntrue\njulia> Ak = q*A;\njulia> integrateK(abs2.(Ak), q) ≈ 0.5 # Same result\ntrue\n\n\n\n\n\n\n","category":"method"},{"location":"#Hankel.integrateR-Tuple{Any,QDHT}","page":"Hankel","title":"Hankel.integrateR","text":"integrateR(A, Q::QDHT; dim=1)\n\nRadial integral of A, over the aperture of Q in real space.\n\nAssuming A contains samples of a function f(r) at sample points Q.r, then integrateR(A, Q) approximates ∫f(r)r dr from r=0 to r=∞.\n\nnote: Note\nintegrateR and integrateK fulfill Parseval's theorem, i.e. for some array A, integrateR(abs2.(A), q) and integrateK(abs2.(q*A), q) are equal, but  integrateR(A, q) and integrateK(q*A, q) are not equal.\n\nExamples\n\njulia> q = QDHT(10, 128); A = exp.(-q.r.^2/2);\njulia> integrateR(abs2.(A), q) ≈ 0.5 # analytical solution of ∫exp(-r²)r dr from 0 to ∞\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#Hankel.onaxis-Tuple{Any,QDHT}","page":"Hankel","title":"Hankel.onaxis","text":"onaxis(Ak, Q::QDHT; dim=Q.dim)\n\nCalculate on-axis sample in space (i.e. at r=0) from transformed array Ak.\n\nExamples\n\njulia> q = QDHT(10, 128); A = exp.(-q.r.^2/2);\njulia> onaxis(q*A, q) ≈ 1 # should be exp(0) = 1\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#Hankel.symmetric-Tuple{Any,QDHT}","page":"Hankel","title":"Hankel.symmetric","text":"symmetric(A, Q::QDHT)\n\nCreate symmetric array from samples in A, including on-axis sample.\n\nGiven A, sampled at [r₁, r₂, r₃, ...], generates array sampled at  [...-r₃, -r₂, -r₁, 0, r₁, r₂, r₃...]\n\nExamples\n\njulia> q = QDHT(10, 128); A = exp.(-q.r.^2);\njulia> As = symmetric(A, q);\njulia> size(As)\n(257,)\njulia> As[1:128] == A[128:-1:1]\ntrue\njulia> As[129] ≈ 1 # should be exp(0) = 1\ntrue\njulia> As[130:end] == A\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Tuple{QDHT,Any}","page":"Hankel","title":"Base.:*","text":"*(Q::QDHT, A)\n\nCalculate the forward quasi-discrete Hankel transform of array A using the QDHT Q.\n\nExamples\n\njulia> q = QDHT(1e-2, 8); A = exp.(-q.r.^2/(1e-3*q.R));\njulia> q*A\n8-element Array{Float64,1}:\n  4.326937831591551e-6\n  2.3341589529175126e-6\n  7.689558743828849e-7\n  1.546419420523699e-7\n  1.8999259906096856e-8\n  1.4159642663129888e-9\n  7.013670190083954e-11\n -6.07681871673291e-13\n\n\n\n\n\n","category":"method"},{"location":"#Base.:\\-Tuple{QDHT,Any}","page":"Hankel","title":"Base.:\\","text":"\\(Q::QDHT, A)\n\nCalculate the inverse quasi-discrete Hankel transform of array A using the QDHT Q.\n\nExamples\n\njulia> q = QDHT(1e-2, 8); A = exp.(-q.r.^2/(1e-3*q.R));\njulia> Ak = q*A;\njulia> q \\ Ak ≈ A\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#Hankel.dimdot-Tuple{Any,Any}","page":"Hankel","title":"Hankel.dimdot","text":"dimdot(v, A; dim=1)\n\nCalculate the dot product between vector v and one dimension of array A, iterating over all other dimensions.\n\n\n\n\n\n","category":"method"},{"location":"#Hankel.dot!-Tuple{Any,Any,AbstractArray{T,1} where T}","page":"Hankel","title":"Hankel.dot!","text":"dot!(out, M, V; dim=1)\n\nMatrix-vector multiplication along specific dimension of array V, storing result in out.\n\nThis is equivalent to iterating over all dimensions of V other than dim and applying the matrix-vector multiplication M * v[..., :, ...], but works by reshaping the array if necessary to take advantage of faster matrix-matrix multiplication. If dim==1, dot! is fastest and allocation-free.\n\n\n\n\n\n","category":"method"},{"location":"#Hankel.oversample-Tuple{Any,QDHT}","page":"Hankel","title":"Hankel.oversample","text":"oversample(A, Q::QDHT; factor::Int=4)\n\nOversample (smooth) the array A, which is sampled with the QDHT Q, by a factor.\n\nThis works like Fourier-domain zero-padding: a new QDHT is created with the same radius, but factor times more points. The existing array is transformed and placed onto this new spatial frequency grid, and the rest filled with zeros. Transforming back yields the same shape in space but with more samples.\n\nnote: Note\nUnlike in zero-padding using FFTs, the old and oversampled spatial grids do not have any sampling points in common.\n\n\n\n\n\n","category":"method"},{"location":"#Hankel.squeeze-Tuple{Number}","page":"Hankel","title":"Hankel.squeeze","text":"squeeze(A; dims)\n\nWrapper around dropdims to handle both numbers (return just the number) and arrays (return dropdims(A; dims)).\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.ldiv!-Tuple{Any,QDHT,Any}","page":"Hankel","title":"LinearAlgebra.ldiv!","text":"ldiv!(Y, Q::QDHT, A)\n\nCalculate the inverse quasi-discrete Hankel transform of array A using the QDHT Q and store the result in Y.\n\nExamples\n\njulia> q = QDHT(1e-2, 8); A = exp.(-q.r.^2/(1e-3*q.R)); Y = similar(A);\njulia> mul!(Y, q, A);\njulia> YY = similar(Y); ldiv!(YY, q, Y);\njulia> YY ≈ A\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.mul!-Tuple{Any,QDHT,Any}","page":"Hankel","title":"LinearAlgebra.mul!","text":"mul!(Y, Q::QDHT, A)\n\nCalculate the forward quasi-discrete Hankel transform of array A using the QDHT Q and store the result in Y.\n\nExamples\n\njulia> q = QDHT(1e-2, 8); A = exp.(-q.r.^2/(1e-3*q.R)); Y = similar(A);\njulia> mul!(Y, q, A)\n8-element Array{Float64,1}:\n  4.326937831591551e-6\n  2.3341589529175126e-6\n  7.689558743828849e-7\n  1.546419420523699e-7\n  1.8999259906096856e-8\n  1.4159642663129888e-9\n  7.013670190083954e-11\n -6.07681871673291e-13\n\n\n\n\n\n","category":"method"}]
}
