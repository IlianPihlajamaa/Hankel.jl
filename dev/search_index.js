var documenterSearchIndex = {"docs":
[{"location":"derivations/#Derivations-1","page":"Derivations","title":"Derivations","text":"","category":"section"},{"location":"derivations/#L2-norm-integrations-1","page":"Derivations","title":"L^2 norm integrations","text":"","category":"section"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"The L^2 norm in the radially symmetric case is","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"leftlVert f(r) rightrVert = 2pi int_0^infty leftvert f(r)rightvert^2 rmathrmdr","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"In the case where f(r) is an electric field, this can be used to calculate the total power P:","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"P(t) = fracepsilon_0 c2 leftlVert E(t r) rightrVert","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"When using a QDHT, this integral can be approximated by a simple dot product, which is implemented in integrateR and integrateK.","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"In the following, we use the 0^mathrmth-order QDHT, but the same derivation holds for other orders: J_0 becomes J_p and J_1 becomes J_p+1 Following eqs. (21)-(24) in Yu et al. we take the integral, expand f(r) in a Fourier-Bessel series, and use the Hankel transform to obtain the series coefficients:","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"f(r) = frac1pi R^2sum_m=1^M tildefleft(fracj_m2pi Rright) J_1^-2(j_m)J_0left(fracj_m rRright)","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"which turns the integral into","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"int_0^R leftvert f(r)rightvert^2 rmathrmdr = frac1pi^2 R^4 sum_nmtildefleft(fracj_n2pi Rright) tildef^*left(fracj_m2pi Rright) J_1^-2(j_n) J_1^-2(j_m) int_0^R J_0left(fracj_n rRright) J_0left(fracj_m rRright)rmathrmdr","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"The integral expression here is","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"int_0^R J_0left(fracj_n rRright) J_0left(fracj_m rRright)rmathrmdr = frac12R^2 J_1^2(j_m) delta_mn","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"where delta_mn is the Kronecker delta, which reduces the sum back to one variable:","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"int_0^R leftvert f(r)rightvert^2 rmathrmdr = frac12pi^2 R^2 sum_m=1^Mleftverttildefleft(fracj_m2pi Rright)rightvert^2 J_1^-2(j_m)","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"If we now define tildeF (this is F_2 in Yu et al.):","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"tildeF(m) = tildefleft(fracj_m2pi Rright) J_1^-1(j_m) fracK2pi","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"we arrive at","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"int_0^R leftvert f(r)rightvert^2 rmathrmdr = frac2K^2R^2sum_m=1^M verttildeF(m)vert^2","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"From Parseval's theorem we know that","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"int_0^R leftvert f(r)rightvert^2 rmathrmdr = int_0^K vert tildef(k)vert^2 kmathrmdk","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"Following the same procedure as above for the k integral we find","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"int_0^K leftvert tildef(k)rightvert^2 kmathrmdk = frac2K^2R^2sum_n=1^N vert F(n)vert^2","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"and hence","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"int_0^R leftvert f(r)rightvert^2 rmathrmdr = frac2K^2R^2sum_n=1^N vert F(n)vert^2 = frac2K^2 sum_n=1^N leftvert fleft(fracj_nKright)rightvert^2 J_1^-2(j_n)","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"This is just the dot product between vert f(r_n) vert^2 and a scaling vector S_R (called scaleR in QDHT):","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"int_0^R leftvert f(r)rightvert^2 rmathrmdr = S_R cdot vert f(r_n) vert^2","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"with","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"S_R(n) = 2K^-2 J_1^-2(j_n)","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"The same derivation holds for the k integral and results in","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"S_K(n) = 2R^-2 J_1^-2(j_n)","category":"page"},{"location":"derivations/#Integration-of-functions-1","page":"Derivations","title":"Integration of functions","text":"","category":"section"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"note: Note\nThe following derivation only applies to the 0^mathrmth-order QDHT, since the identity used for the integral over J_0 cannot be used for higher orders.","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"For integration of the form","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"int_0^R f(r) rmathrmdr","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"we cannot use Parseval's theorem. Instead, following a similar approach we arrive at","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"int_0^R f(r) rmathrmdr = frac1pi R^2 sum_m=1^M tildefleft(fracj_m2pi Rright)J_1^-2(j_m) int_0^R J_0left(fracj_m rRright)rmathrmdr","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"Using","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"int_0^x x J_0(x)mathrmdx = xJ_1(x)","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"the integral evaluates to","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"int_0^R J_0left(fracj_m rRright)rmathrmdr = fracR^2j_m J_1(j_m)","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"and so","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"int_0^R f(r) rmathrmdr = frac1pi sum_m=1^M frac1j_mtildefleft(fracj_m2pi Rright) J_1^-1(j_m) = frac2K sum_m=1^M frac1j_m tildeF(m)","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"If we now use the QDHT as defined in Yu et al.,","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"tildeF(m) = sum_n=1^N C_mnF(n)","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"with","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"C_mn = frac2S J_0left(fracj_n j_mSright)J_1^-1(j_n)J_1^-1(j_m)","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"after some algebra we arrive at","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"int_0^R f(r) rmathrmdr = frac4K^2 sum_n=1^N J_1^-2(j_n)f(r_n) sum_m=1^M frac1j_mJ_0left(fracj_n j_mSright)J_1^-1(j_m)","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"When taking into account that S = j_N+1, the sum over m is approximately 12 for all values of n (this was verified numerically). This leaves us with","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"int_0^R f(r) rmathrmdr approx frac2K^2 sum_n=1^N J_1^-2(j_n)f(r_n)","category":"page"},{"location":"derivations/#","page":"Derivations","title":"Derivations","text":"as in the case of integrals over vert f(r)vert^2.","category":"page"},{"location":"#Hankel-1","page":"Documentation","title":"Hankel","text":"","category":"section"},{"location":"#","page":"Documentation","title":"Documentation","text":"Hankel implements the quasi-discrete Hankel transform (QDHT) as introduced in H. F. Johnson, Comput. Phys. Commun., 43, 2 (1987), laid out for 0-order in L. Yu, et al., Optics Letters 23 (1998), and extended to higher orders in M. Guizar-Sicairos and J. C. Guti√©rrez-Vega, JOSA A 21, 53 (2004). We generalized the cylindrical QDHT in the above publications to its (hyper)spherical form. The forward p^mathrmth-order (hyper)spherical Hankel transform of the radially symmetric function f(r) is defined as","category":"page"},{"location":"#","page":"Documentation","title":"Documentation","text":"tildef(k) = c_n^-1 int_0^infty f(r) j_p^n(kr) r^nmathrmdr","category":"page"},{"location":"#","page":"Documentation","title":"Documentation","text":"where c_n is a constant (see sphbesselj_scale), and j_p^n(x) is the p^mathrmth-order (hyper)spherical Bessel function of the first kind with spherical dimension n (see sphbesselj). Correspondingly, the inverse transform is","category":"page"},{"location":"#","page":"Documentation","title":"Documentation","text":"f(r) = c_n^-1 int_0^infty tildef(k) j_p^n(kr) k^nmathrmdk","category":"page"},{"location":"#","page":"Documentation","title":"Documentation","text":"Note that here, k includes the factor of 2pi, i.e. it is spatial angular frequency.","category":"page"},{"location":"#","page":"Documentation","title":"Documentation","text":"The remainder of the documentation considers without loss of generalization only the cylindrical case (n=1, with j_p^n(x) = J_p(x)).","category":"page"},{"location":"#","page":"Documentation","title":"Documentation","text":"The QDHT approximates these transforms under the assumption that f(r) = 0 for r  R where R is the aperture size. By expanding f(r) as a Fourier-Bessel series and choosing to sample f(r) at coordinates r_n = j_nRj_N+1, where j_n is the n^mathrmth zero of J_p(x) and N is the number of samples, the Hankel transform turns into a matrix-vector multiplication.","category":"page"},{"location":"#","page":"Documentation","title":"Documentation","text":"Hankel follows the AbstractFFTs approach of planning a transform in advance by creating a QDHT object, which can then be used to transform an array using multiplication (* or mul!) and to transform back by left-division (\\ or ldiv!). In contrast to AbstractFFTs, however, pre-planning a transform is required since the transform only works properly if the sampling points are chosen for a particular combination of sample number N and aperture size R. The workflow to transform a function f(r) is therefore as follows:","category":"page"},{"location":"#","page":"Documentation","title":"Documentation","text":"using Hankel # hide\nimport Hankel: besselj_zero, besselj # hide\nj01 = besselj_zero(0, 1)\nR = 1\nN = 8\nq = QDHT(0, R, N)\nf(r) = besselj(0, r*j01/R)\nfr = f.(q.r)\nfk = q * fr # 0th-order QDHT => fk should have only the first entry non-zero","category":"page"},{"location":"#Normalisation-1","page":"Documentation","title":"Normalisation","text":"","category":"section"},{"location":"#","page":"Documentation","title":"Documentation","text":"The transform as implemented here is unitary, i.e.","category":"page"},{"location":"#","page":"Documentation","title":"Documentation","text":"using Hankel # hide\nimport Hankel: besselj_zero, besselj # hide\nj01 = besselj_zero(0, 1) # hide\nR = 1 # hide\nN = 512 # hide\nq = QDHT(R, N) # hide\nf(r) = besselj(0, r*j01/R) # hide\nfr = f.(q.r) # hide\nq \\ (q * fr) ‚âà fr","category":"page"},{"location":"#","page":"Documentation","title":"Documentation","text":"The transform satisfies Parseval's Theorem. To calculate the L^2 norm (e.g. energy in a signal) with correct scaling, use integrateR in real (r) space and integrateK in reciprocal (k) space. For an explanation of how these functions work, see the Derivations page.","category":"page"},{"location":"#On-axis-and-symmetric-samples-1","page":"Documentation","title":"On-axis and symmetric samples","text":"","category":"section"},{"location":"#","page":"Documentation","title":"Documentation","text":"The QDHT does not contain a sample on axis, i.e. at r=0, but for the 0^mathrmth-order QDHT, it can be obtained using onaxis, which takes the transformed array as its input. This is because the on-axis sample is obtained from","category":"page"},{"location":"#","page":"Documentation","title":"Documentation","text":"f(r=0) = int_0^infty tildef(k) J_0(0) kmathrmdk","category":"page"},{"location":"#","page":"Documentation","title":"Documentation","text":"Note here why this does not work for other values of p: J_p(0) = 0  forall  p0.","category":"page"},{"location":"#","page":"Documentation","title":"Documentation","text":"Given an array A, the convenience method symmetric produces the symmetric array, i.e. given A, sampled at r‚ÇÅ r‚ÇÇ r‚ÇÉ , it generates the array sampled at -r‚ÇÉ -r‚ÇÇ -r‚ÇÅ 0 r‚ÇÅ r‚ÇÇ r‚ÇÉ. This works also for higher-dimensional arrays. The corresponding spatial coordinates can be obtained with Rsymmetric.","category":"page"},{"location":"#Function-Reference-1","page":"Documentation","title":"Function Reference","text":"","category":"section"},{"location":"#","page":"Documentation","title":"Documentation","text":"Modules = [Hankel]","category":"page"},{"location":"#Hankel.QDHT","page":"Documentation","title":"Hankel.QDHT","text":"QDHT{p, n}(R, N; dim=1)\nQDHT([p, ] R, N; dim=1)\nQDHT(p, [n, ] R, N; dim=1)\n\np-th order quasi-discrete Hankel transform over aperture radius R with N samples which transforms along dimension dim. If not given, p defaults to 0, and n the spherical dimension defaults to 1 (cylindrical).\n\nAfter:\n\n[1] L. Yu, M. Huang, M. Chen, W. Chen, W. Huang, and Z. Zhu, Optics Letters 23 (1998)\n\n[2] M. Guizar-Sicairos and J. C. Guti√©rrez-Vega, JOSA A 21, 53 (2004)\n\n[3] H. F. Johnson, Comput. Phys. Commun., 43, 2 (1987)\n\nbut with some alterations:\n\nThe transform matrix T is not the same as C/T defined in [1, 2] but is more like the form used in equation 14 of [3]. Instead of dividing by J_1(Œ±_pn) J_1(Œ±_pm) we divide by J_1(Œ±_pn)^2. This cancels out the factor between f and F so we do not have to mutltiply (divide) by J_1(Œ±_pn) (J_1(Œ±_pm)) before and after applying the transform matrix.\n\nFollows AbstractFFT approach of applying fwd and inv transform with mul and ldiv.\n\nTo calculate radial integrals of functions sampled using QDHT, use integrateR and integrateK.\n\nThe type of the coefficients is inferred from the type of R (but is promoted to be at least Float), so for arbitrary precision use QDHT([p, ] BigFloat(R), ...).\n\n\n\n\n\n","category":"type"},{"location":"#Hankel.Rsymmetric-Tuple{QDHT}","page":"Documentation","title":"Hankel.Rsymmetric","text":"Rsymmetric(Q::QDHT)\n\nCreate radial coordinate array to go along with symmetric(A, Q::QDHT).\n\nExamples\n\njulia> q = QDHT{0, 1}(10, 4);\njulia> q.r\n4-element Array{Float64,1}:\n 1.6106347946239767\n 3.697078919099734\n 5.795844623798052\n 7.8973942990196395\njulia> Rsymmetric(q)\n9-element Array{Float64,1}:\n -7.8973942990196395\n -5.795844623798052\n -3.697078919099734\n -1.6106347946239767\n  0.0\n  1.6106347946239767\n  3.697078919099734\n  5.795844623798052\n  7.8973942990196395\n\n\n\n\n\n","category":"method"},{"location":"#Hankel.integrateK-Tuple{Any,QDHT}","page":"Documentation","title":"Hankel.integrateK","text":"integrateK(Ak, Q::QDHT; dim=1)\n\nRadial integral of A, over the aperture of Q in reciprocal space.\n\nAssuming A contains samples of a function f(k) at sample points Q.k, then integrateR(A, Q) approximates ‚à´f(k)k dk from k=0 to k=‚àû.\n\nnote: Note\nintegrateR and integrateK fulfill Parseval's theorem, i.e. for some array A, integrateR(abs2.(A), q) and integrateK(abs2.(q*A), q) are equal, but integrateR(A, q) and integrateK(q*A, q) are not equal.\n\nExamples\n\njulia> q = QDHT{0, 1}(10, 128); A = exp.(-q.r.^2/2);\njulia> integrateR(abs2.(A), q) ‚âà 0.5 # analytical solution of ‚à´exp(-r¬≤)r dr from 0 to ‚àû\ntrue\njulia> Ak = q*A;\njulia> integrateK(abs2.(Ak), q) ‚âà 0.5 # Same result\ntrue\n\n\n\n\n\n\n","category":"method"},{"location":"#Hankel.integrateR-Tuple{Any,QDHT}","page":"Documentation","title":"Hankel.integrateR","text":"integrateR(A, Q::QDHT; dim=1)\n\nRadial integral of A, over the aperture of Q in real space.\n\nAssuming A contains samples of a function f(r) at sample points Q.r, then integrateR(A, Q) approximates ‚à´f(r)r dr from r=0 to r=‚àû.\n\nnote: Note\nintegrateR and integrateK fulfill Parseval's theorem, i.e. for some array A, integrateR(abs2.(A), q) and integrateK(abs2.(q*A), q) are equal, but integrateR(A, q) and integrateK(q*A, q) are not equal.\n\nwarning: Warning\nusing integrateR to integrate a function (i.e. A rather than abs2(A)) is only supported for the 0th-order QDHT. For more details see Derivations.\n\nExamples\n\njulia> q = QDHT{0, 1}(10, 128); A = exp.(-q.r.^2/2);\njulia> integrateR(abs2.(A), q) ‚âà 0.5 # analytical solution of ‚à´exp(-r¬≤)r dr from 0 to ‚àû\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#Hankel.onaxis-Union{Tuple{n}, Tuple{Any,QDHT{0,n,T} where T<:Real}} where n","page":"Documentation","title":"Hankel.onaxis","text":"onaxis(Ak, Q::QDHT; dim=Q.dim)\n\nCalculate on-axis sample in space (i.e. at r=0) from transformed array Ak.\n\nnote: Note\nonaxis is currently only supported for 0-order transforms\n\nExamples\n\njulia> q = QDHT{0, 1}(10, 128); A = exp.(-q.r.^2/2);\njulia> onaxis(q*A, q) ‚âà 1 # should be exp(0) = 1\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#Hankel.symmetric-Tuple{Any,QDHT}","page":"Documentation","title":"Hankel.symmetric","text":"symmetric(A, Q::QDHT)\n\nCreate symmetric array from samples in A, including on-axis sample.\n\nGiven A, sampled at [r‚ÇÅ, r‚ÇÇ, r‚ÇÉ, ...], generates array sampled at [...-r‚ÇÉ, -r‚ÇÇ, -r‚ÇÅ, 0, r‚ÇÅ, r‚ÇÇ, r‚ÇÉ...]\n\nExamples\n\njulia> q = QDHT{0, 1}(10, 128); A = exp.(-q.r.^2);\njulia> As = symmetric(A, q);\njulia> size(As)\n(257,)\njulia> As[1:128] == A[128:-1:1]\ntrue\njulia> As[129] ‚âà 1 # should be exp(0) = 1\ntrue\njulia> As[130:end] == A\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Tuple{QDHT,Any}","page":"Documentation","title":"Base.:*","text":"*(Q::QDHT, A)\n\nCalculate the forward quasi-discrete Hankel transform of array A using the QDHT Q.\n\nExamples\n\njulia> q = QDHT{0, 1}(1e-2, 8); A = exp.(-q.r.^2/(1e-3*q.R));\njulia> q*A\n8-element Array{Float64,1}:\n  4.326937831591551e-6\n  2.3341589529175126e-6\n  7.689558743828849e-7\n  1.546419420523699e-7\n  1.8999259906096856e-8\n  1.4159642663129888e-9\n  7.013670190083954e-11\n -6.07681871673291e-13\n\n\n\n\n\n","category":"method"},{"location":"#Base.:\\-Tuple{QDHT,Any}","page":"Documentation","title":"Base.:\\","text":"\\(Q::QDHT, A)\n\nCalculate the inverse quasi-discrete Hankel transform of array A using the QDHT Q.\n\nExamples\n\njulia> q = QDHT{0, 1}(1e-2, 8); A = exp.(-q.r.^2/(1e-3*q.R));\njulia> Ak = q*A;\njulia> q \\ Ak ‚âà A\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#Hankel.dimdot-Tuple{Any,Any}","page":"Documentation","title":"Hankel.dimdot","text":"dimdot(v, A; dim=1)\n\nCalculate the dot product between vector v and one dimension of array A, iterating over all other dimensions.\n\n\n\n\n\n","category":"method"},{"location":"#Hankel.dot!-Tuple{Any,Any,AbstractArray{T,1} where T}","page":"Documentation","title":"Hankel.dot!","text":"dot!(out, M, V; dim=1)\n\nMatrix-vector multiplication along specific dimension of array V, storing result in out.\n\nThis is equivalent to iterating over all dimensions of V other than dim and applying the matrix-vector multiplication M * v[..., :, ...], but works by reshaping the array if necessary to take advantage of faster matrix-matrix multiplication. If dim==1, dot! is fastest and allocation-free.\n\n\n\n\n\n","category":"method"},{"location":"#Hankel.order-Union{Tuple{QDHT{p,n,T} where T<:Real where n}, Tuple{p}} where p","page":"Documentation","title":"Hankel.order","text":"order(q::QDHT)\n\nOrder of transform q.\n\n\n\n\n\n","category":"method"},{"location":"#Hankel.oversample-Union{Tuple{n}, Tuple{p}, Tuple{Any,QDHT{p,n,T} where T<:Real}} where n where p","page":"Documentation","title":"Hankel.oversample","text":"oversample(A, Q::QDHT; factor::Int=4)\n\nOversample (smooth) the array A, which is sampled with the QDHT Q, by a factor.\n\nThis works like Fourier-domain zero-padding: a new QDHT is created with the same radius, but factor times more points. The existing array is transformed and placed onto this new spatial frequency grid, and the rest filled with zeros. Transforming back yields the same shape in space but with more samples.\n\nnote: Note\nUnlike in zero-padding using FFTs, the old and oversampled spatial grids do not have any sampling points in common.\n\n\n\n\n\n","category":"method"},{"location":"#Hankel.sphbesselj-Tuple{Any,Any,Any}","page":"Documentation","title":"Hankel.sphbesselj","text":"sphbesselj(p, n, x)\n\n(Hyper)spherical Bessel function of order p and spherical dimension n. The hyperspherical Bessel function generalizes the cylindrical and spherical Bessel functions to the n-sphere (embedded in ‚Ñù^n+1). It is given as\n\nj_p^n(x) = c_n x^-(n-1)2 J_p + (n-1)2(x)\n\nwhere c_n is a normalization factor defined by sphbesselj_scale. Note that n is not an exponent here.\n\nIt has as its special cases:\n\nCylindrical Bessel function (n=1): j_p^1(x) = J_p(x)\nSpherical Bessel function (n=2): j_p^2(x) = j_p(x)\n\nAfter:\n\n[1] J. S. Avery, J. E. Avery. Hyperspherical Harmonics And Their Physical Applications.     Singapore: World Scientific Publishing Company, 2017.\n\n\n\n\n\n","category":"method"},{"location":"#Hankel.sphbesselj_scale-Tuple{Any}","page":"Documentation","title":"Hankel.sphbesselj_scale","text":"sphbesselj_scale(n)\n\nReturn the normalization factor for the (hyper)spherical Bessel function (sphbesselj) with spherical dimension n, given as c_n = sqrtfracœÄ2 for even n and 1 otherwise.\n\nAfter:\n\n[1] J. S. Avery, J. E. Avery. Hyperspherical Harmonics And Their Physical Applications.     Singapore: World Scientific Publishing Company, 2017.\n\n\n\n\n\n","category":"method"},{"location":"#Hankel.sphbesselj_zero-Tuple{Any,Any,Any}","page":"Documentation","title":"Hankel.sphbesselj_zero","text":"sphbesselj_zero(p, n, m)\n\nGet the mth zero of the (hyper)spherical Bessel function of order p and spherical dimension n.\n\nSee sphbesselj.\n\n\n\n\n\n","category":"method"},{"location":"#Hankel.sphericaldim-Union{Tuple{QDHT{p,n,T} where T<:Real}, Tuple{n}, Tuple{p}} where n where p","page":"Documentation","title":"Hankel.sphericaldim","text":"sphericaldim(q::QDHT)\n\nSpherical dimension n of transform q.\n\nDimension of the n-sphere over whose radial coordinate the bases of the transform q are orthogonal polynomials. For the circle, n=1, and for the sphere, n=2.\n\nSee sphbesselj.\n\n\n\n\n\n","category":"method"},{"location":"#Hankel.squeeze-Tuple{Number}","page":"Documentation","title":"Hankel.squeeze","text":"squeeze(A; dims)\n\nWrapper around dropdims to handle both numbers (return just the number) and arrays (return dropdims(A; dims)).\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.ldiv!-Tuple{Any,QDHT,Any}","page":"Documentation","title":"LinearAlgebra.ldiv!","text":"ldiv!(Y, Q::QDHT, A)\n\nCalculate the inverse quasi-discrete Hankel transform of array A using the QDHT Q and store the result in Y.\n\nExamples\n\njulia> q = QDHT{0, 1}(1e-2, 8); A = exp.(-q.r.^2/(1e-3*q.R)); Y = similar(A);\njulia> mul!(Y, q, A);\njulia> YY = similar(Y); ldiv!(YY, q, Y);\njulia> YY ‚âà A\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.mul!-Tuple{Any,QDHT,Any}","page":"Documentation","title":"LinearAlgebra.mul!","text":"mul!(Y, Q::QDHT, A)\n\nCalculate the forward quasi-discrete Hankel transform of array A using the QDHT Q and store the result in Y.\n\nExamples\n\njulia> q = QDHT{0, 1}(1e-2, 8); A = exp.(-q.r.^2/(1e-3*q.R)); Y = similar(A);\njulia> mul!(Y, q, A)\n8-element Array{Float64,1}:\n  4.326937831591551e-6\n  2.3341589529175126e-6\n  7.689558743828849e-7\n  1.546419420523699e-7\n  1.8999259906096856e-8\n  1.4159642663129888e-9\n  7.013670190083954e-11\n -6.07681871673291e-13\n\n\n\n\n\n","category":"method"}]
}
